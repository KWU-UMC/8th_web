- `gcTime`은 무엇인가요? 🍠
  gcTime은 Garbage Collection Time의 줄임말으로 쿼리 데이터가 사용되지 않을때 메모리에서 완전히 제거되기까지 기다리는 시간을 의미한다 즉 쿼리데이터가 모든 컴포넌트에서 사용되지 않으면 Query는 캐시를 제거하게 되는데 이때 바로 지우는것이 아닌 gcTime만큼 대기한 후에 삭제한다.
- `staleTime`은 무엇인가요? 🍠
  staleTime은 쿼리데이터가 stale(오래됨)으로 간주되기까지의 시간으로 이 시간동안은 Query가 자동으로 refetch하지 않고 캐시된 데이터를 신선한 것으로 간주한다.
- 두 값을 어떤 식으로 설정하여야 `캐싱 전략에 유리`한가요? 🍠
  데이터의 종류에따라 나누면 되는데 만약 자주 바뀌는 데이터 같은 경우는 staleTime을 0으로 설정해놓고 gcTime을 짧게 설정하게되면 메모리 절약 효과를 볼 수 있다. 반면에 자주 바뀌지 않는 데이터 같은 경우는 staleTime은 10분~infinity로 설정하고 gcTime은 안써도 한동안은 캐시가 유지되게 시간을 설정해놓으면 된다.
- **`오프셋 기반 페이지네이션`**과 **`커서 기반 페이지네이션`**에 대해 정리해보세요! 🍠
  - `오프셋 기반 페이지네이션`의 장/단점 (`offset-based pagination`) 🍠
    - `오프셋 기반 페이지네이션`은 무엇인가요? 🍠
      전체 데이터 중에서 특정 시작점으로부터 몇 개 가져오는 방식으로 offset은 몇번째 데이터부터 가져올지에 대한 정보를 limit은 한 페이지에 몇개를 가져올지의 정보를 담고 있습니다.
    - `오프셋 기반 페이지네이션`의 장점? 🍠
      구조가 단순하고 페이지 번호 기반 UI에 적합하다.
    - `오프셋 기반 페이지네이션`의 단점? 🍠
      데이터 양이 많아 질수록 성능이 저하되며 중간에 데이터가 추가되면 페이지가 밀려 순서 깨짐이 발생할 수 있다. 또한 무한 스크롤에는 적합하지 않다
  - `커서 기반 페이지네이션`의 장/단점 (`cursor-based pagination`) 🍠
    - `커서 기반 페이지네이션`은 무엇인가요? 🍠
      마지막으로 본 데이터의 식별자를 기준으로 그 다음 데이터를 요청하는 방식으로 cursor는 이전 요청에서 마지막으로 본 항목의 ID나 타임스탬프 정보를 담고 있고 limit는 이 커서 이후에 몇개의 요청이 필요한지에 관한 정보를 담고 있다.
    - `커서 기반 페이지네이션`의 장점 🍠
      커서 기반 페이지네이션은 중간에 데이터가 삽입되거나 삭제되어도 커서 기준으로 이후 데이터만 가져오므로 순서가 밀리지 않는다는 장점이 있고 다음 커서로 더 가져오기를 통한 무한 스크롤에 최적화 되어있다는 장점 역시 가지고 있다.
    - `커서 기반 페이지네이션`의 단점 🍠
      페이지 번호 UI를 부여하기 어려우며 이전 페이지의 탐색 같은 경우는 별도의 로직을 구현해야함 또한 커서 관리를 필요로 하는 어려움이 있음. - Skeleton UI를 활용했을 때 장점에 대해 정리해주세요 🍠
      기다리는동안 사용자의 스트레스를 줄여줄수 있고 데이터 로딩된 후에 레이아웃이 바로 바뀌는것이 아닌 자연스럽게 채워지기에 깜빡임을 최소화할수 있는 장점이 있다.
