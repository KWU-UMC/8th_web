### 키워드 정리 🍠

- JWT

  - JWT(Json Web Token) 란 무엇인가?
    ### JWT (Json Web Token)이란 무엇인가?
    **정의**
    `JWT`는 JSON 형식의 데이터를 안전하게 전달하기 위한 토큰입니다. 서버는 사용자가 로그인하면 `JWT`를 생성하여 클라이언트에 전달하고, 클라이언트는 이 **토큰을 API 요청 시 함께 보내어 인증된 사용자임을 증명**합니다.
    **용도**
    **인증(Authentication):** 사용자가 로그인한 후, 서버는 **`JWT`**를 발급하고 클라이언트는 이후 요청 시 이 토큰을 사용하여 본인의 신원을 증명합니다.
    **정보 교환(Information Exchange):** **`JWT`**에는 사용자 정보나 기타 필요한 데이터를 담아 안전하게 전달할 수 있습니다.
  - JWT의 구성
    ### JWT의 구성
    JWT는 세 부분으로 구성되어 있으며, 각각은 점(`.`)으로 구분됩니다.
    **1. 헤더 (Header)**
    - 토큰의 타입(JWT)과 사용된 서명 알고리즘(예: HS256, RS256 등)을 명시합니다.
      EX)
    ```tsx
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    ```
    **2. 페이로드 (Payload)**
    - 사용자 정보, 권한, 만료 시간(exp) 등 실제로 전달하고자 하는 데이터를 포함합니다.
    - 이 정보는 일반적으로 암호화되지 않으므로 민감한 데이터는 포함하지 않아야 합니다.
    ```tsx
    {
      "sub": "1234567890",
      "name": "Matthew Kim",
      "iat": 1516239022,
      "exp": 1516242622
    }
    ```
    **3. 서명(Signature)**
    - 헤더와 페이로드를 Base64Url로 인코딩한 값을 비밀키(또는 공개/개인키 쌍)를 사용하여 서명합니다.
    - 이 서명은 토큰이 변조되지 않았음을 확인하는 역할을 합니다.
    ***
  - JWT의 동작 원리 (전지적 WEB 시점)

    ### JWT의 동작 원리 (WEB 시점)

    1. **로그인 및 토큰 발급:**

       사용자가 로그인하면, 서버는 사용자를 인증한 후 JWT를 생성하여 클라이언트에 전달합니다.

    2. **토큰 저장:**

       클라이언트는 이 JWT를 브라우저의 로컬 스토리지 또는 쿠키에 저장할 수 있습니다.

       > 주의: 저장 방식에 따라 XSS나 CSRF 공격 위험이 있으므로 보안에 신경 써야 합니다.

    3. **요청 시 토큰 전달:**

       클라이언트는 API 요청 시 HTTP 헤더의 **`Authorization`** 필드에 **`"Bearer {토큰}"`** 형식으로 JWT를 포함합니다.

       ```tsx
       Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
       ```

    4. **서버에서 토큰 검증:**

       서버는 수신한 JWT를 검증하여 사용자의 인증 정보를 확인하고 요청을 처리합니다.

    ***

  - JWT 사용 시 보안 고려 사항
    ### JWT 사용 시 보안 고려 사항
    - **민감한 정보 포함 주의:**
      JWT의 페이로드는 암호화되지 않고 Base64Url로 인코딩되므로, 사용자 개인정보나 민감한 데이터를 담지 않아야 합니다.
    - **만료시간(exp) 설정:**
      토큰 탈취 시 위험을 줄이기 위해 반드시 만료 시간을 설정하고, 필요 시 갱신(refresh) 로직을 구현합니다.
    - **통신 보안:**
      HTTPS 프로토콜을 사용하여 네트워크 상의 데이터 노출을 방지합니다.
    - **저장 위치:**
      로컬 스토리지, 세션 스토리지 또는 쿠키에 저장할 때 XSS, CSRF 공격에 주의해야 하며, 보안 설정을 강화합니다.

- Cookie 🍪
  - 쿠키의 구성 요소
    ### 쿠키의 구성 요소
    쿠키는 여러 속성을 가지며, 각 속성은 쿠키의 동작과 보안에 영향을 미칩니다.
    - **이름(Name)과 값(Value)**
      쿠키의 핵심 데이터로, 이름과 그에 해당하는 값을 저장합니다.
    - **도메인(Domain)**
      쿠키가 유효한 도메인을 지정합니다. 지정된 도메인 내에서만 쿠키가 전송됩니다.
    - **경로(Path)**
      쿠키가 적용되는 URL 경로를 지정하여, 특정 경로에서만 쿠키가 사용되도록 제한할 수 있습니다.
    - **만료 시간(Expires) 및 최대 수명(Max-Age)**
      쿠키의 유효 기간을 설정합니다. 만료 시간이 지나면 브라우저는 해당 쿠키를 삭제합니다.
    - **보안 속성**
      - **Secure:** HTTPS 연결일 때만 쿠키가 전송됩니다.
      - **HttpOnly:** 클라이언트 측 스크립트(JavaScript)에서 접근할 수 없도록 하여 XSS 공격 위험을 줄입니다.
      - **SameSite:** 쿠키가 크로스 사이트 요청에 포함되는 방식을 제어해 CSRF 공격을 방지할 수 있습니다.
  - 쿠키의 동작 원리
    ### 쿠키의 동작 원리
    - **설정:**
      - 서버는 HTTP 응답 헤더의 `Set-Cookie` 필드를 사용해 쿠키를 브라우저에 설정합니다.
      - 예
        ```
        Set-Cookie: sessionId=abc123; Path=/; Expires=Wed, 21 Oct 2025 07:28:00 GMT; Secure; HttpOnly; SameSite=Strict
        ```
    - **저장**
      - 브라우저는 서버로부터 받은 쿠키를 내부 저장소에 보관하며, 지정된 도메인 및 경로에 따라 관리합니다.
    - **전송**
      - 사용자가 같은 도메인으로 요청을 보낼 때마다 브라우저는 해당 쿠키를 HTTP 요청 헤더의 `Cookie` 필드를 통해 자동으로 전송합니다.
  - 쿠키의 사용 예시
    ### 쿠키의 사용 예시
    쿠키는 다양한 용도로 활용됩니다. 몇 가지 예시는 다음과 같습니다.
    - **세션 관리**
      - 사용자가 로그인하면 서버는 세션 ID를 쿠키에 저장해, 이후 요청 시 사용자 인증 정보를 확인합니다.
    - **사용자 선호도 저장**
      - 테마, 언어, 페이지 레이아웃 등의 개인 설정을 쿠키에 저장하여 다음 방문 시 같은 환경을 제공합니다.
    - **분석 및 추적**
      - 사용자의 방문 기록이나 행동 패턴을 분석하기 위해 쿠키를 사용하여 데이터를 수집할 수 있습니다.
  - 보안 고려 사항
    ### 보안 고려 사항
    쿠키는 매우 유용하지만, 잘못 사용하면 보안 취약점이 될 수 있습니다.
    - **XSS (교차 사이트 스크립팅):**
      - 쿠키에 민감한 데이터를 저장할 때 `HttpOnly` 옵션을 사용해 클라이언트 스크립트로부터 보호합니다.
    - **CSRF (사이트 간 요청 위조):**
      - `SameSite` 옵션을 적절히 설정해, 다른 도메인에서 발생하는 요청에 쿠키가 포함되지 않도록 합니다.
    - **쿠키 도난:**
      - `Secure` 옵션을 사용해 `HTTPS` 연결에서만 쿠키가 전송되도록 하며, HTTPS 사용을 권장합니다.
    - **쿠키 크기 및 수 제한:**
      - `쿠키는 용량이 제한`되어 있으며, `도메인 당 저장할 수 있는 쿠키 수에도 제한`이 있으므로 필요한 데이터만 저장해야 합니다.
- Refresh Token 🍠

  - Refresh Token 정의
    ### Refresh Token 정의
    - **Access Token과의 차이:**
      Access Token은 보호된 리소스에 접근할 수 있도록 해주지만, 만료 시간이 짧게 설정되어 있습니다. 반면, Refresh Token은 상대적으로 긴 유효 기간을 가지며, 만료된 Access Token을 갱신하는 데 사용됩니다.
    - **역할:**
      - 사용자가 로그인을 다시 하지 않아도 지속적인 인증 상태를 유지하게 해줍니다.
      - 보안을 강화하면서도 사용자 경험을 개선합니다.
  - Refresh Token 동작 원리
    ### Refresh Token 동작 원리
    - **초기 발급**
      사용자가 인증을 완료하면, 인가 서버는 `Access Token`과 함께 `Refresh Token`을 함께 발급합니다.
    - **토큰 저장**
      클라이언트는 `Access Token`과 `Refresh Token`을 안전하게 저장합니다.
      - 보안상의 이유로 `HTTPOnly 쿠키`나 안전한 스토리지에 저장하는 것이 좋습니다.
    - **Access Token 만료**
      일정 시간이 지나 `Access Token`이 만료되면, 클라이언트는 `Refresh Token`을 이용해 새로운 `Access Token`을 요청합니다.
    - **토큰 갱신**
      인가 서버는 `Refresh Token`의 유효성을 검증한 후 새로운 `Access Token`(및 경우에 따라 새로운 `Refresh Token`)을 발급합니다.
  - 보안 고려 사항
    ### 보안 고려 사항
    - **안전한 저장소**
      `Refresh Token`은 민감 정보이므로, XSS나 CSRF 공격에 취약하지 않은 `HTTPOnly 쿠키`나 보안 스토리지에 저장해야 합니다.
    - **유효 기간 관리**
      `Refresh Token`의 만료 시간을 적절히 설정하여 장기적인 보안 위협을 최소화합니다.
    - **토큰 재사용 방지**
      `Refresh Token`이 탈취될 경우를 대비하여, 인가 서버에서 한 번 사용된 `Refresh Token`을 무효화하거나 새로운 토큰으로 교체하는 정책을 적용할 수 있습니다.
    - **폐기 정책**
      사용자가 로그아웃하거나 의심스러운 활동이 감지되면, `Refresh Token`을 즉시 폐기하여 추가적인 인증 요청이 불가능하도록 해야 합니다.
  - XSS 공격 / CSRF 공격 🍠
      <aside>
      🍠
      
      XSS 공격과 CSRF 공격에 대해 직접 정리해보세요!
      
      </aside>
      
      - XSS 공격
          - Cross Site Scripting의 약자.
          - 게시판이나 웹 메일 등에 자바 스크립트와 같은 스크립트 코드를 삽입 해 개발자가 고려하지 않은 기능이 작동하게 하는 공격
          - 사용자(클라이언트)를 대상으로 한 공격
          
          | Reflected XSS | - 취약점이 존재하는 페이지를 미리 탐색한 후, XSS 공격을 위한 스크립트가 포함된 URL을 공격 대상자에게 노출시키는 공격
          
          1️⃣ 사용자에게 XSS 공격 스크립트가 포함된 URL 노출
          2️⃣ 사용자가 서버에 URL을 통해 Request를 전송
          3️⃣ 서버가 해당 스크립트를 포함한 Response를 전송 |
          | --- | --- |
          | Stored XSS | - 웹사이트의 게시판에 스크립트를 삽입하는 공격
          
          1️⃣ 서버에 XSS 공격 스크립트를 포함한 게시글 포스팅
          2️⃣ 사용자에게 해당 게시글 URL 노출
          3️⃣ 사용자가 게시글을 확인하고 해당 URL에 대한 요청을 서버에 Request 전송 
          4️⃣ 웹 서버에서 스크립트를 포함한 Response를 전송 |
          | DOM Based XSS | - 클라이언트 측에서 DOM(JavaScript)을 동적으로 조작하는 로직을 악용해, 악성 스크립트를 실행시키는 공격
          
          1️⃣ 공격자가 악성 스크립트가 포함된 URL 생성
          2️⃣ 사용자에게 해당 URL을 노출
          3️⃣ 사용자가 URL을 클릭하면, 브라우저에서 해당 페이지 로딩
          4️⃣ 페이지 내 JavaScript가 `document.locaiton`, `document.URL` 등의 값을 DOM에 반영
          5️⃣ 그 과정에서 악성 스크립트가 DOM에 삽입되어 브라우저에서 실행 |
      - CSRF 공격
          - Cross Site Request Forgery의 약자.
          - 웹 보안 취약점의 일종이며, 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격
          - CSRF 성공 조건
              - 사용자는 보안이 취약한 서버로부터 이미 로그인되어 있는 상태
              - 쿠키 기반의 서버 세션 정보를 획득 가능
              - 공격자는 서버를 공격하기 위한 요청 방법에 대해 미리 파악
          - 공격 과정
              
              1️⃣ 사용자가 보안이 취약한 서버에 로그인
              
              2️⃣ 서버에 저장된 세션 정보를 사용할 수 있는 session ID가 사용자의 브라우저 쿠키에 저장됨
              
              3️⃣ 사용자가 악성 스크립트 페이지를 누름
              
              4️⃣ 사용자가 악성 스크립트가 작성된 페이지 접근 시 웹 브라우저에 의해 쿠키에 저장된 session ID와 함께 서버로 요청됨
              
              5️⃣ 서버는 쿠키에 담긴 session ID를 통해 해당 요청이 인증된 사용자로부터 온 것으로 판단하고 처리함

- Protected Route 🍠

  - Protected Route 니가 뭔데~🎶

    ### Protected Route 니가 뭔데~🎶

    - **정의:**
      `Protected Route`는 인증 상태(예: 로그인 여부)에 따라 특정 라우트를 보호하는 컴포넌트입니다. 사용자가 인증된 경우에만 접근을 허용하고, 그렇지 않은 경우 로그인 페이지나 오류 페이지로 리다이렉션 시킵니다.
    - **목적:**

      - 사용자 데이터 보호
      - 민감한 정보에 대한 접근 제한
      - 사용자 경험 개선 (잘못된 접근 시 안내 제공)
      <aside>
      🗣

      **`Protected Route`**를 적용하지 않은 경우 어떤 문제가 발생할까요?

      **`/admin/users` 페이지의 역할**

      해당 페이지는 관리자(admin)만 접근할 수 있도록 설계되어, 웹사이트에 가입한 모든 유저들의 정보를 보여줍니다.

      **Protected Route를 적용하지 않은 경우 발생하는 문제**

      **일반 사용자 접근:** 일반 유저도 `/admin/users` 페이지에 접근할 수 있게 되어, 관리자 전용 정보(다른 유저들의 개인정보 등)가 노출됩니다.

      **보안 취약점:** 이는 서비스의 보안에 심각한 위험을 초래하며, 데이터 유출이나 권한 없는 정보 접근으로 이어질 수 있습니다.

      </aside>

  - Protected Route의 동작 원리

    ### Protected Route의 동작 원리

    1. **인증 확인**

       애플리케이션의 상태(예: Context, Redux, 또는 로컬 스토리지 등)를 통해 사용자의 로그인 상태나 권한을 확인합니다.

    2. **조건 분기**
       - 인증된 사용자인 경우: 요청한 컴포넌트를 렌더링합니다.
       - 인증되지 않은 사용자인 경우: 로그인 페이지, 홈 페이지 등으로 리다이렉션합니다.
    3. **리다이렉션 처리**

       미인증 상태에서 접근을 시도하면, 사용자에게 로그인 후 원래 요청한 페이지로 돌아갈 수 있도록 리다이렉션 정보를 전달할 수 있습니다.

  - Protected Route를 직접 구현해보세요 🍠

    ### 실습 🍠

    서버가 없으니, 아래와 같이 가상의 역할을 만들어 직접 구현해보세요!

    ```tsx
    const role = "ADMIN";

    import { Navigate } from "react-router-dom";

    const ProtectedRoute = ({ role, allowedRoles, children }) => {
      if (!allowedRoles.includes(role)) {
        return <Navigate to="/" replace />;
      }

      return children;
    };

    export default ProtectedRoute;
    ```

- OAuth 2.0

  - OAuth 2.0 이란?
    ### OAuth 2.0이란?
    - **정의**
      OAuth 2.0은 사용자가 자신의 리소스(예: 프로필, 이메일 등)를 제3자 애플리케이션과 공유할 수 있도록, 안전하고 제한적인 접근 권한을 위임하는 프로토콜입니다.
    - **목적**
      - **보안 강화:** 사용자 비밀번호를 노출하지 않고, 액세스 토큰을 통해 리소스 접근을 제어합니다.
      - **유연성 제공:** 다양한 클라이언트(웹, 모바일 등)에서 사용 가능한 여러 인증 방식을 지원합니다.
  - 주요 구성 요소
    ### OAuth 2.0 주요 구성 요소
    OAuth 2.0은 다음 네 가지 핵심 구성 요소로 이루어져 있습니다.
    ***
    **1. 리소스 소유자 (Resouce Owner)**
    - 데이터나 리소스의 소유자(주로 사용자)로, 자신의 정보를 제3자에게 공유할 수 있는 권한을 가지고 있습니다.
      **2. 클라이언트 (Client)**
    - 리소스 소유자의 데이터에 접근하려는 애플리케이션입니다. 예를 들어, 서드파티 앱이나 웹사이트가 이에 해당합니다.
      **3. 리소스 서버 (Resource Server)**
    - 보호된 리소스를 호스팅하는 서버로, 클라이언트의 요청 시 액세스 토큰을 확인하여 데이터에 대한 접근 권한을 검증합니다.
      **4. 인가 서버 (Authorization Server)**
    - 리소스 소유자의 인증을 담당하며, 클라이언트에게 액세스 토큰을 발급하는 역할을 합니다.
  - OAuth 2.0 인증 및 권한 부여 프로세스

    ### OAuth 2.0 인증 및 권한 부여 프로세스

    **OAuth 2.0**의 전형적인 흐름은 다음 단계로 진행됩니다.

    ***

    1. **사용자 인증 및 권한 부여 요청**

       클라이언트 애플리케이션이 **리소스 소유자**에게 특정 리소스에 접근할 수 있도록 허용할지를 요청합니다.

    2. **인가 코드 발급 (Authorization Code Grant)**

       인가 서버는 **리소스 소유자**가 동의하면 클라이언트에게 인가 코드를 발급합니다. 이 코드는 일회용이며, 액세스 토큰 요청 시 사용됩니다.

    3. **액세스 토큰 발급:**

       클라이언트는 받은 인가 코드를 인가 서버에 제출하고, 유효하다면 액세스 토큰을 발급받습니다. 이 토큰은 **리소스 서버**에 보호된 데이터를 요청할 때 사용됩니다.

    4. **리소스 접근:**

       클라이언트는 액세스 토큰을 사용해 **리소스 서버**에서 보호된 데이터를 요청합니다.

  - OAuth 2.0의 인증 방식 (Grant Types)
    ### OAuth 2.0의 인증 방식 (Grant Types)
    OAuth 2.0은 다양한 상황에 맞게 여러 가지 인증 방식을 제공합니다.
    ### 1. Authorization Code Grant
    - **용도:** 서버 사이드 애플리케이션에서 주로 사용됩니다.
    - **특징:** 인가 코드를 통해 액세스 토큰을 교환하므로, 비교적 보안성이 높습니다.
    ### 2. Implicit Grant
    - **용도:** 브라우저 기반 애플리케이션(예: SPA)에서 사용됩니다.
    - **특징:** 액세스 토큰이 직접 클라이언트로 전달되지만, 보안 측면에서는 약간의 위험이 있을 수 있습니다.
    ### 3. Resource Owner Password Credentials Grant
    - **용도:** 사용자의 신뢰도가 높은 클라이언트(예: 자체 앱)에서 사용됩니다.
    - **특징:** 사용자 이름과 비밀번호를 직접 받아 토큰을 요청하므로, 다른 방식보다 보안 위험이 있을 수 있습니다.
    ### 4. Client Credentials Grant
    - **용도:** 서버 간 통신이나, 애플리케이션이 자신을 인증할 때 사용됩니다.
    - **특징:** 클라이언트 자신의 자격 증명을 사용해 토큰을 발급받습니다.
    ### 5. Refresh Token
    - **용도:** 만료된 액세스 토큰을 갱신하기 위해 사용됩니다.
    - **특징:** 장기적으로 사용자의 인증 상태를 유지할 수 있도록 도와줍니다.
  - OAuth 2.0과 OpenID Connect
    ### OAuth 2.0과 OpenID Connect
    - **OAuth 2.0**
      주로 권한 부여에 초점을 맞추어, 리소스 접근 권한을 관리합니다.
    - **OpenID Connect (OIDC)**
      OAuth 2.0 위에 구축된 인증 계층으로, 사용자 인증 및 프로필 정보를 제공하여 단일 로그인을 구현할 때 사용됩니다.
  - OAuth 2.0 장점 및 단점
    ### OAuth 2.0 장점 및 단점
    ### 1. 장점
    - **보안성 강화:** 사용자의 민감한 자격 증명을 노출하지 않고, 액세스 토큰을 통한 접근 제어가 가능합니다.
    - **유연성:** 다양한 클라이언트와 인증 방식을 지원하며, 서버와 클라이언트를 분리하여 확장이 용이합니다.
    - **표준화:** 널리 사용되는 표준 프로토콜로, 다양한 플랫폼과 서비스 간에 호환성이 좋습니다.
    ### 2. 단점
    - **구현 복잡성:** 여러 가지 플로우와 구성 요소 때문에 초기 설정 및 구현이 다소 복잡할 수 있습니다.
    - **보안 취약점 가능성:** 잘못된 구현이나 설정 시 리다이렉션 URI 변조, 토큰 탈취 등의 보안 위험이 발생할 수 있습니다.
